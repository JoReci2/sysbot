= Guide du développeur

== Introduction

Ce guide s'adresse aux développeurs qui souhaitent contribuer à SysBot ou étendre ses fonctionnalités. Vous apprendrez l'architecture, la configuration de l'environnement de développement et comment créer des modules et plugins personnalisés.

== Configuration de l'environnement de développement

=== Prérequis

* Python 3.7 ou supérieur (Python 3.8+ recommandé)
* Git
* pip
* Outil d'environnement virtuel (venv ou virtualenv)

=== Cloner le dépôt

[source,bash]
----
# Cloner le dépôt
git clone https://github.com/JoReci2/sysbot.git
cd sysbot

# Créer un environnement virtuel
python -m venv venv

# Activer l'environnement virtuel
# Sur Linux/macOS :
source venv/bin/activate

# Sur Windows :
venv\Scripts\activate
----

=== Installer les dépendances de développement

[source,bash]
----
# Installer les outils de développement
pip install build ruff bandit radon safety

# Installer le package en mode développement
pip install -e .
----

== Architecture

=== Vue d'ensemble

SysBot suit une architecture modulaire avec ces composants principaux :

* *Sysbot* - Classe principale qui orchestre toutes les opérations
* *Connecteurs* - Gestion des connexions spécifiques au protocole
* *Modules* - Fonctionnalités de haut niveau pour les systèmes
* *Plugins* - Composants utilitaires et intégrations
* *Gestionnaire de secrets* - Stockage sécurisé des données sensibles

=== Structure des répertoires

[source,text]
----
sysbot/
├── sysbot/
│   ├── __init__.py
│   ├── Sysbot.py           # Classe principale
│   ├── connectors/         # Implémentations des connecteurs
│   │   ├── ssh.py
│   │   ├── winrm.py
│   │   ├── http.py
│   │   ├── socket.py
│   │   └── localhost.py
│   ├── modules/            # Modules de fonctionnalités
│   │   ├── linux.py
│   │   └── windows.py
│   ├── plugins/            # Composants plugins
│   │   └── listener.py
│   └── utils/              # Fonctions utilitaires
├── tests/                  # Suites de tests
├── docs/                   # Documentation
└── setup.py               # Configuration du package
----

== Développement de connecteurs

=== Créer un nouveau connecteur

Les connecteurs gèrent les connexions spécifiques au protocole. Voici un modèle :

[source,python]
----
class MonNouveauConnecteur:
    """Connecteur pour mon protocole personnalisé"""
    
    def __init__(self, host, port=1234, login=None, password=None):
        self.host = host
        self.port = port
        self.login = login
        self.password = password
        self.session = None
    
    def open_session(self):
        """Ouvrir une connexion"""
        # Implémenter la logique de connexion
        self.session = self._connect()
        return {
            "StatusCode": 0,
            "Result": "Connecté avec succès",
            "Error": "",
            "Metadata": {}
        }
    
    def execute_command(self, command, **kwargs):
        """Exécuter une commande"""
        # Implémenter la logique d'exécution
        return {
            "StatusCode": 0,
            "Result": "Sortie de la commande",
            "Error": "",
            "Metadata": {}
        }
    
    def close_session(self):
        """Fermer la connexion"""
        if self.session:
            self.session.close()
            self.session = None
        return {
            "StatusCode": 0,
            "Result": "Session fermée",
            "Error": "",
            "Metadata": {}
        }
----

=== Format de réponse du connecteur

Tous les connecteurs doivent retourner un dictionnaire standardisé :

[source,python]
----
{
    "StatusCode": 0,        # 0 = succès, >0 = erreur
    "Result": "données",    # Données de sortie
    "Error": "",            # Message d'erreur si StatusCode > 0
    "Metadata": {}          # Métadonnées supplémentaires
}
----

== Développement de modules

=== Créer un nouveau module

Les modules fournissent des fonctionnalités de haut niveau :

[source,python]
----
class MonModule:
    """Module pour une fonctionnalité spécifique"""
    
    def __init__(self, sysbot_instance):
        self.bot = sysbot_instance
    
    def ma_fonctionnalite(self, alias, param1, param2):
        """Effectuer une opération de haut niveau"""
        # Utiliser l'instance SysBot pour exécuter des commandes
        resultat = self.bot.execute_command(
            alias, 
            f"ma_commande {param1} {param2}"
        )
        
        # Traiter et retourner les résultats
        return self._traiter_resultat(resultat)
    
    def _traiter_resultat(self, resultat):
        """Méthode d'aide pour traiter les résultats"""
        if resultat["StatusCode"] == 0:
            return resultat["Result"]
        else:
            raise Exception(f"Erreur : {resultat['Error']}")
----

== Développement de plugins

=== Créer un nouveau plugin

Les plugins étendent les capacités de SysBot :

[source,python]
----
class MonPlugin:
    """Plugin pour une fonctionnalité personnalisée"""
    
    def __init__(self, config=None):
        self.config = config or {}
    
    def initialiser(self):
        """Initialiser le plugin"""
        pass
    
    def traiter(self, donnees):
        """Traiter les données"""
        # Implémenter la logique du plugin
        return donnees
    
    def nettoyer(self):
        """Nettoyer les ressources"""
        pass
----

== Tests

=== Écrire des tests

Utilisez unittest pour les tests :

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestMonModule(unittest.TestCase):
    
    def setUp(self):
        self.bot = Sysbot()
    
    def tearDown(self):
        self.bot.close_all_sessions()
    
    def test_ma_fonctionnalite(self):
        """Tester ma fonctionnalité"""
        # Implémenter la logique de test
        self.assertTrue(True)


if __name__ == '__main__':
    unittest.main()
----

=== Exécuter les tests

[source,bash]
----
# Exécuter tous les tests
python -m unittest discover tests

# Exécuter des tests spécifiques
python -m unittest tests.test_mon_module
----

== Linting et qualité du code

=== Utiliser Ruff

[source,bash]
----
# Vérifier les problèmes de code
ruff check sysbot/

# Corriger automatiquement les problèmes
ruff check --fix sysbot/
----

=== Analyse de sécurité

[source,bash]
----
# Vérifier les vulnérabilités de sécurité
bandit -r sysbot/

# Vérifier la complexité du code
radon cc sysbot/ -a
----

== Directives de contribution

=== Flux de travail Git

[source,bash]
----
# Créer une branche de fonctionnalité
git checkout -b feature/ma-nouvelle-fonctionnalite

# Faire des commits
git add .
git commit -m "Ajouter une nouvelle fonctionnalité"

# Pousser vers le dépôt distant
git push origin feature/ma-nouvelle-fonctionnalite

# Créer une pull request sur GitHub
----

=== Standards de code

* Suivre PEP 8 pour le style de code Python
* Écrire des docstrings pour toutes les fonctions et classes
* Ajouter des tests pour les nouvelles fonctionnalités
* Maintenir la couverture de code au-dessus de 80%
* Utiliser des noms de variables et de fonctions descriptifs

=== Documentation

* Mettre à jour la documentation lors de l'ajout de fonctionnalités
* Utiliser le format AsciiDoc pour la documentation
* Inclure des exemples de code dans la documentation
* Maintenir le changelog à jour

== Construction et publication

=== Construction du package

[source,bash]
----
# Construire le package
python -m build

# Vérifier le package
twine check dist/*
----

=== Publication sur PyPI

[source,bash]
----
# Publication sur TestPyPI (pour les tests)
twine upload --repository testpypi dist/*

# Publication sur PyPI (production)
twine upload dist/*
----

== Ressources

=== Documentation utile

* xref:references.adoc[Référence de l'API]
* xref:robotframework.adoc[Guide Robot Framework]
* xref:unittest.adoc[Guide Unittest]

=== Liens externes

* https://github.com/JoReci2/sysbot[Dépôt GitHub]
* https://github.com/JoReci2/sysbot/issues[Suivi des problèmes]
* https://peps.python.org/pep-0008/[PEP 8 - Guide de style]

== Support

Pour des questions de développement :

* Ouvrir une issue sur GitHub
* Consulter les issues existantes
* Rejoindre les discussions de la communauté
