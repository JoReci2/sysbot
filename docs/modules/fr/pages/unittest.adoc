= Travailler avec unittest

== Introduction

SysBot peut être utilisé avec les suites de tests Python unittest, fournissant une interface puissante pour l'automatisation des tests système dans un environnement Python natif.

== Configuration

=== Installation

Installez SysBot (unittest est inclus dans la bibliothèque standard Python) :

[source,bash]
----
pip install sysbot
----

== Exemples de base

=== Test de connexion SSH simple

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestConnexionSSH(unittest.TestCase):
    
    def setUp(self):
        """Configurer avant chaque test"""
        self.bot = Sysbot()
    
    def tearDown(self):
        """Nettoyer après chaque test"""
        self.bot.close_all_sessions()
    
    def test_connexion_ssh_basique(self):
        """Tester une connexion SSH basique"""
        self.bot.open_session(
            alias="serveur_test",
            protocol="ssh",
            product="bash",
            host="192.168.1.100",
            login="utilisateur",
            password="mot_de_passe"
        )
        
        resultat = self.bot.execute_command("serveur_test", "hostname")
        self.assertIsNotNone(resultat)
        self.assertIn("Result", resultat)


if __name__ == '__main__':
    unittest.main()
----

=== Test de connexion WinRM

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestConnexionWindows(unittest.TestCase):
    
    def setUp(self):
        self.bot = Sysbot()
        self.bot.open_session(
            alias="serveur_windows",
            protocol="winrm",
            product="powershell",
            host="192.168.1.200",
            login="administrateur",
            password="mot_de_passe"
        )
    
    def tearDown(self):
        self.bot.close_all_sessions()
    
    def test_obtenir_info_ordinateur(self):
        """Tester la récupération d'informations sur l'ordinateur"""
        resultat = self.bot.execute_command(
            "serveur_windows", 
            "Get-ComputerInfo"
        )
        self.assertEqual(resultat["StatusCode"], 0)
        self.assertIn("Windows", resultat["Result"])


if __name__ == '__main__':
    unittest.main()
----

=== Test d'API HTTP

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestAPIREST(unittest.TestCase):
    
    def setUp(self):
        self.bot = Sysbot()
        self.bot.open_session(
            alias="mon_api",
            protocol="http",
            product="basicauth",
            host="api.exemple.com",
            login="utilisateur_api",
            password="cle_api"
        )
    
    def tearDown(self):
        self.bot.close_all_sessions()
    
    def test_obtenir_utilisateurs(self):
        """Tester le point de terminaison GET /utilisateurs"""
        reponse = self.bot.execute_command(
            "mon_api", 
            "GET", 
            endpoint="/utilisateurs"
        )
        self.assertEqual(reponse["StatusCode"], 0)
        self.assertIsNotNone(reponse["Result"])
    
    def test_creer_utilisateur(self):
        """Tester le point de terminaison POST /utilisateurs"""
        donnees = {
            "nom": "Jean Dupont",
            "email": "jean@exemple.com"
        }
        reponse = self.bot.execute_command(
            "mon_api",
            "POST",
            endpoint="/utilisateurs",
            body=donnees
        )
        self.assertEqual(reponse["StatusCode"], 0)


if __name__ == '__main__':
    unittest.main()
----

== Organisation des tests

=== Structure du projet

[source,text]
----
projet/
├── tests/
│   ├── __init__.py
│   ├── test_connexions.py
│   ├── test_linux.py
│   ├── test_windows.py
│   └── test_api.py
├── resources/
│   └── config.py
└── requirements.txt
----

=== Utilisation de setUpClass et tearDownClass

Pour les ressources partagées entre les tests :

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestSuiteLinux(unittest.TestCase):
    
    @classmethod
    def setUpClass(cls):
        """Configurer une fois pour toute la classe de tests"""
        cls.bot = Sysbot()
        cls.bot.open_session(
            alias="serveur_linux",
            protocol="ssh",
            product="bash",
            host="192.168.1.100",
            login="utilisateur",
            password="mot_de_passe"
        )
    
    @classmethod
    def tearDownClass(cls):
        """Nettoyer après tous les tests"""
        cls.bot.close_all_sessions()
    
    def test_systeme_fichiers(self):
        """Tester les opérations du système de fichiers"""
        resultat = self.bot.execute_command("serveur_linux", "ls -la /tmp")
        self.assertEqual(resultat["StatusCode"], 0)
    
    def test_processus(self):
        """Tester les opérations de processus"""
        resultat = self.bot.execute_command("serveur_linux", "ps aux")
        self.assertEqual(resultat["StatusCode"], 0)


if __name__ == '__main__':
    unittest.main()
----

=== Utilisation de sous-tests

Pour des tests paramétrés :

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestMultiplesHotes(unittest.TestCase):
    
    def setUp(self):
        self.bot = Sysbot()
    
    def tearDown(self):
        self.bot.close_all_sessions()
    
    def test_ping_multiples_hotes(self):
        """Tester le ping sur plusieurs hôtes"""
        hotes = [
            ("serveur1", "192.168.1.100"),
            ("serveur2", "192.168.1.101"),
            ("serveur3", "192.168.1.102"),
        ]
        
        for alias, host in hotes:
            with self.subTest(host=host):
                self.bot.open_session(
                    alias=alias,
                    protocol="ssh",
                    product="bash",
                    host=host,
                    login="utilisateur",
                    password="mot_de_passe"
                )
                resultat = self.bot.execute_command(alias, "hostname")
                self.assertEqual(resultat["StatusCode"], 0)


if __name__ == '__main__':
    unittest.main()
----

== Utilisation avancée

=== Utilisation de modules

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestModuleLinux(unittest.TestCase):
    
    def setUp(self):
        self.bot = Sysbot()
        self.bot.open_session(
            alias="serveur",
            protocol="ssh",
            product="bash",
            host="192.168.1.100",
            login="utilisateur",
            password="mot_de_passe"
        )
        self.bot.load_module("linux")
    
    def tearDown(self):
        self.bot.close_all_sessions()
    
    def test_info_systeme(self):
        """Tester la récupération d'informations système"""
        info = self.bot.modules.linux.get_system_info("serveur")
        self.assertIsNotNone(info)
        self.assertIn("hostname", info.lower())
    
    def test_liste_processus(self):
        """Tester la liste des processus"""
        processus = self.bot.modules.linux.list_processes("serveur")
        self.assertIsNotNone(processus)
        self.assertGreater(len(processus), 0)


if __name__ == '__main__':
    unittest.main()
----

=== Gestion des secrets

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestAvecSecrets(unittest.TestCase):
    
    def setUp(self):
        self.bot = Sysbot()
        # Stocker les secrets
        self.bot.store_secret("mot_de_passe_ssh", "valeur_secrete")
    
    def tearDown(self):
        self.bot.close_all_sessions()
    
    def test_connexion_avec_secret(self):
        """Tester la connexion utilisant des secrets stockés"""
        mot_de_passe = self.bot.get_secret("mot_de_passe_ssh")
        self.bot.open_session(
            alias="serveur_securise",
            protocol="ssh",
            product="bash",
            host="192.168.1.100",
            login="utilisateur",
            password=mot_de_passe
        )
        resultat = self.bot.execute_command("serveur_securise", "whoami")
        self.assertEqual(resultat["StatusCode"], 0)


if __name__ == '__main__':
    unittest.main()
----

== Exécution des tests

=== Exécuter tous les tests

[source,bash]
----
# Découvrir et exécuter tous les tests
python -m unittest discover tests

# Exécuter un fichier de test spécifique
python -m unittest tests.test_connexions

# Exécuter une classe de test spécifique
python -m unittest tests.test_connexions.TestConnexionSSH

# Exécuter un test spécifique
python -m unittest tests.test_connexions.TestConnexionSSH.test_connexion_ssh_basique
----

=== Mode verbeux

[source,bash]
----
# Exécuter les tests en mode verbeux
python -m unittest discover tests -v
----

=== Avec couverture de code

[source,bash]
----
# Installer coverage
pip install coverage

# Exécuter les tests avec couverture
coverage run -m unittest discover tests
coverage report
coverage html  # Générer un rapport HTML
----

== Bonnes pratiques

=== Utiliser des méthodes d'assertion appropriées

[source,python]
----
# Au lieu de
self.assertTrue(resultat["StatusCode"] == 0)

# Utiliser
self.assertEqual(resultat["StatusCode"], 0)

# Pour les vérifications de contenu
self.assertIn("attendu", resultat["Result"])
self.assertIsNotNone(resultat)
self.assertGreater(len(liste), 0)
----

=== Isoler les tests

Chaque test doit être indépendant :

[source,python]
----
class TestIsole(unittest.TestCase):
    
    def setUp(self):
        # Configurer un nouvel état pour chaque test
        self.bot = Sysbot()
    
    def tearDown(self):
        # Nettoyer après chaque test
        self.bot.close_all_sessions()
----

=== Utiliser des skips et des expected failures

[source,python]
----
import unittest
from sysbot.Sysbot import Sysbot


class TestAvecSkips(unittest.TestCase):
    
    @unittest.skip("Temporairement désactivé")
    def test_temporairement_desactive(self):
        pass
    
    @unittest.skipIf(condition, "Raison du skip")
    def test_conditionnel(self):
        pass
    
    @unittest.expectedFailure
    def test_echec_connu(self):
        self.fail("Ce test est connu pour échouer")


if __name__ == '__main__':
    unittest.main()
----

== Prochaines étapes

* Consultez le xref:robotframework.adoc[guide Robot Framework] pour l'intégration des tests
* Explorez le xref:references.adoc[référence de l'API] pour les capacités avancées
* Lisez le xref:developer.adoc[guide du développeur] pour contribuer au projet
