= System Production Specification
:toc:
:toclevels: 1

include::partial$overview.adoc[]

[IMPORTANT] 
.Pre-requisite
====
* Thales Digital Factory gitlab access
* Skill:
** Python
** Git
** Asciidoc
====

== Code management 

=== Repository structure

The repository is organized into two main directories and multiple files:

[listing]
----
ğŸ“‚ {{modules_name}} <1>
  ğŸ“‚ docs <2>
    ğŸ“‚ modules
      ğŸ“‚ {{modules_name}}
        ğŸ“‚ images
        ğŸ“‚ pages
            ğŸ“„ index.adoc
        ğŸ“„ nav.adoc
    ğŸ“‚ sources
      ğŸ“‚ mermaid
    ğŸ“„ antora.yml
  ğŸ“‚ {{modules_name}} <3>
    ğŸ“„ __init__.py
    ğŸ“„ some_script.yml
  ğŸ“„ .gitlab-ci.yml
  ğŸ“„ antora-playbook.yml
  ğŸ“„ LICENSE <4>
  ğŸ“„ pyproject.toml
  ğŸ“„ setup.py <5>
----
<1> Name of the gitlab repository
<2> Documentation written in Asciidoc with antora
<3> Directory contain the python module
<4> License of the package
<5> Python package configuration file

A gitlab repository template is available in TASQ project_template/template_pypi_module.

=== Merge request

When creating a merge request, itâ€™s essential to follow best practices to ensure a smooth and efficient review process. Start by keeping your changes focused and your branch up to date with the target branch, typically through regular rebases rather than merge commits. Rebasing ensures a clean, linear commit history, making it easier for reviewers to follow the evolution of your changes. Write clear, descriptive commit messages that explain the why behind your changes, not just the what. In the merge request description, provide detailed context about the purpose of the changes, their impact, and any specific areas requiring attention during the review. Break large merge requests into smaller, logical pieces whenever possible to simplify the review process. Always run all tests locally and verify that your changes meet the projectâ€™s quality and coding standards before submitting the request. Finally, address feedback promptly and maintain an open line of communication with reviewers to resolve any concerns efficiently. These practices foster collaboration, maintain code quality, and ensure a more manageable codebase over time.

=== Branch

The project follows a structured workflow with two main branches: main and release. These branches are protected against direct pushes and merges to maintain code stability and ensure quality. Contributions begin by creating a new branch from the release branch, using a clear naming convention such as feature/<description> or fix/<description>. Developers work on their changes within these branches, and if needed, can create additional sub-branches for specific tasks, like dev-fix/<description> branching from dev. Once the work is completed, a merge request is submitted to the release branch. This request must include a detailed description of the changes, their purpose, and any relevant context to facilitate the review process. After review and approval, changes from feature or fix branches are merged into release. Finally, the main branch is updated only from the release branch during stable releases, which are tagged with version numbers such as 1.0.0. This workflow ensures a robust integration process, encouraging collaboration while maintaining the integrity of the production codebase.

image::sps_gitgraph.svg[GitGraph diagram, 500, 500]

[WARNING] 
====
All merge requests that do not follow the following guidelines or the design will be rejected !
====

=== CI/CD Delivery

image::sps_cicd_timeline.svg[CICD diagram, 500, 500]

The CI/CD build the pypi package and push it on the gitlab registry. Then the documation was buid and push in gitlab pages.

=== Versionning strategy

The versioning strategy for this project is designed to clearly communicate the scope and impact of changes while maintaining traceability through automated build identifiers. The version format is structured as major.minor.patch-build, such as 1.0.0-build1. Here is how each component is defined:

- Major Version (1.x.x): The major version is incremented for significant changes that impact the core engine of the system. This includes changes such as adding or removing APIs, modifications to the database schema, or altering the authentication method. These updates often require substantial testing and may introduce breaking changes for users.
- Minor Version (x.1.x): The minor version increases when modifications involve updates to client test configurations. Examples include changes to user interfaces, connectors, or drivers that affect client workflows but do not alter the underlying engine.
- Patch Version (x.x.1): The patch version is incremented specifically for the addition of new drivers. These are typically smaller, incremental updates that expand compatibility without altering existing functionality.
- Build Number (x.x.xb1): The build number increments with each run of the CI/CD pipeline. This ensures every build can be uniquely identified, providing a precise reference for debugging or deployment. To implement this, the CI/CD pipeline will set the build identifier dynamically using the CI_COMMIT_TAG, following the format 1.0.0-build1. The latest successfully built and functional version will be tagged accordingly for reference.

== Work on the fork

[IMPORTANT] 
.Pre-requisite
====
* https://www.python.org/downloads/[Python 3.x]
* https://git-scm.com/downloads/guis[Git client]
* Python IDE ( ex: https://code.visualstudio.com/[Visual Studio Code])
====

=== Set up the environment

[source,shell]
----
git clone https://gitlab.sf-prod.ahe.tdp.infra.thales/ndcn/ivq_drawer/tasq/pypi/sysbotDrivers <1>
cd sysbotDrivers <2>
git branch fix/bug <3>
python -m venv .venv <4>
.\venv\Scripts\activate.bat <5>
----
<1> Clone the repository. In this exemple `sysbotDrivers` is the repository name
<2> Move to the repository
<3> Create a new branche related with the new feature or bug fix
<4> Create a new python environment
<5> Enter in the python environment

=== Build and install the application locally

[NOTE] 
====
See modules or connector documentation to understand how to develop it
====

[source,shell]
----
pip install build <1>
python -m build . <2>
pip install dist/my-package.tar.gz <3>
----
<1> Install the requirments to build python packages
<2> Build the package. (Execute this command in the root of gitlab repository directory)
<3> Install the package in the .venv environment (The package code are store in .venv/Lib/`package_name`)

=== Create the merge request

[source,shell]
----
git rebase <1>
git commit -c "my new feature" <2>
git push origin feature/your-feature-name <3>
----
<1> Ensure the branch is up-to-date with the release branch and resolve conflict
<2> Commit the modification
<3> Push the modification on repository

. On a web browser navigate to the repository
. Click on merge request tab
. Click on `new merge request` 
.. In the â€œSource branchâ€ dropdown, select your feature branch (e.g., feature/your-feature-name).
.. In the â€œTarget branchâ€ dropdown, select the release branch.
.. Clic on `Compare branch and continue`
. Provide a Detailed Description
.. Mark the merge request as draft until the modification are done
.. Fill in the title and description for your Merge Request. Make sure to provide a clear and detailed description of the changes you have made.
.. Include any relevant information, such as why the changes were made, what issues they address, and any potential impacts on the existing codebase.
. Add Reviewers
.. Actually only thibault-t.scire and baudouin.landais are the maintainer and can approuved and merge.
.. Optionally, add labels to categorize your Merge Request (e.g., bug, enhancement, documentation).
.	Submit the Merge Request

=== Build the package

Once the merge requests have been processed, a tag should be created to define the beta version (e.g., 0.0.1b1, 0.0.1b2, 0.0.1b3, etc.). Once the version is deemed stable and satisfactory, a second tag should be applied to mark the official release (e.g., 0.0.1). Each time a tag is applied, the CI/CD pipeline will automatically build a new package with the corresponding version and push it to the GitLab package registry.

Version tagging is essential for structured software deployment, ensuring that each stage of development is properly tested before a final release. The beta versions (b1, b2, etc.) allow for incremental improvements and validation through testing. The CI/CD pipeline automates this process by generating a build for every new tag, ensuring that each version is stored and accessible in the GitLab package registry. This approach guarantees traceability, reproducibility, and efficient deployment management.

[source,shell]
.Install beta package with pip 
====
pip install sysbot==0.0.1b1
====

=== Build the package

Once the merge requests have been processed, a tag should be created to define the beta version (e.g., 0.0.1b1, 0.0.1b2, 0.0.1b3, etc.). Once the version is deemed stable and satisfactory, a second tag should be applied to mark the official release (e.g., 0.0.1). Each time a tag is applied, the CI/CD pipeline will automatically build a new package with the corresponding version and push it to the GitLab package registry.

Version tagging is essential for structured software deployment, ensuring that each stage of development is properly tested before a final release. The beta versions (b1, b2, etc.) allow for incremental improvements and validation through testing. The CI/CD pipeline automates this process by generating a build for every new tag, ensuring that each version is stored and accessible in the GitLab package registry. This approach guarantees traceability, reproducibility, and efficient deployment management.

[source,shell]
.Install beta package with pip 
====
pip install sysbot==0.0.1b1
====

== Create a New Connector

The following instructions explain how to develop new connectors for various types of protocols (e.g., REST API, SSH, WinRM, etc.). Each connector should follow the same structure to ensure consistency and scalability in the codebase.

=== Connector Structure

[listing]
----
ğŸ“‚ sysbot <1>
  ğŸ“‚ sysbot <2>
    ğŸ“‚ connectors <3>
        ğŸ“‚ http <5>
          ğŸ“„ redfish.py <6>
        ğŸ“„ ConnectorHandler.py <4>
----
<1> Name of the gitlab repository
<2> Directory contain the python module
<3> Directory contain all the connectors
<4> Connection manager that allows you to link modules and connectors
<5> Each directory are a protocol (e.g., http, ssh, winrm, etc.)
<6> The connector which will have the name of the technology that it allows to connect

Each connector needs to be a single `.py` file stored in the `resources.lib.connectors` folder. The file should contain a class with the minimal of the following methods:

* `open_session`: Opens a session with the remote service.
* `execute_command`: Executes a command on the remote service.
* `close_session`: Closes the session.
* `execute_file`: Push and execute the file. (actually only available on windows and linux with ssh protocol)

The naming convention is that the file name are lower and the class name must be the same and start with a capital letter. (e.g. ssh.py -> class Ssh())

=== Methods

==== `open_session(host: str, port: int, login: str, password: str) -> dict`

This method establishes the connection with the remote service and returns the necessary session information for the remote service.

**Parameters:**

- `host`: The IP address or hostname of the remote service.
- `port`: The port of the remote service.
- `login`: The login for the remote service.
- `password`: The password for the remote service.

==== `execute_command(session: dict, command: str, options: any) -> any`

This method executes a command on the remote service and returns the result.

**Parameters:**

- `session`: The session parameter is a dictionary returned by the `open_session` method, containing all the necessary variables to execute the command.
- `command`: The command to be executed.
- `options`: Optionnal parameter

==== `close_session(session: dict) -> None`

This method terminates the active session.

**Parameters:**

- `session`: The session parameter is a dictionary returned by the `open_session` method, containing all the necessary variables to execute the command.

=== Documentation 

Each function or class need to be documented with reST docstring.

[source,python]
----
class Ios(object):
    """
    This is a class for interacting with Cisco IOS devices.
    It uses the Netmiko library to establish and manage SSH connections.
    """

    def open_session(self, host: str, port: int, login: str, password: str) -> dict:
        """
        Opens an SSH session to a Cisco IOS device.
        """
        try:
            client = ConnectHandler(device_type='cisco_ios', ip=host, port=port, username=login, password=password)
            return client
        except Exception as e:
            raise Exception(f"Failed to open session: {str(e)}")

    def execute_command(self, session: dict, command: str, options: any) -> any:
        """
        Executes a command on a Cisco IOS device via SSH.
        """
        try:
            output = session.send_command(command)
            return output
        except Exception as e:
            raise Exception(f"Failed to execute command: {str(e)}")

    def close_session(self, session: dict) -> None:
        """
        Closes an active SSH session to a Cisco IOS device.
        """
        try:
            session.disconnect()
        except Exception as e:
            raise Exception(f"Failed to close session: {str(e)}")
----

== Create a new drivers
== Create a new drivers

The following instructions explain how to develop a new driver. A driver is a class that interacts with a specific service, typically within the context of a system or application, and exposes functionality via Robot Framework keywords. Each driver class should follow a consistent structure to ensure scalability and ease of use.

=== Drivers Structure

[listing]
----
ğŸ“‚ sysbotWindows <1>
  ğŸ“‚ docs <2>
  ğŸ“‚ sysbotWindows <3>
    ğŸ“„ __init__.py <4>
    ğŸ“„ Windows.py <5>
----
<1> Root repository folder
<2> Antora documentations repository
<3> Package folders
<4> init files used to identify python folders (mandarory on each package folders)
<5> sysbot module
=== Drivers Structure

[listing]
----
ğŸ“‚ sysbotWindows <1>
  ğŸ“‚ docs <2>
  ğŸ“‚ sysbotWindows <3>
    ğŸ“„ __init__.py <4>
    ğŸ“„ Windows.py <5>
----
<1> Root repository folder
<2> Antora documentations repository
<3> Package folders
<4> init files used to identify python folders (mandarory on each package folders)
<5> sysbot module

Each driver should be a single .py file stored in the `resources.lib.drivers` folder. The file should contain a class with the following structure:

- Inherit from a `ConnectorInterface` to ensure connection and session management. Abstraction of the `ConnectorInterface` method is required to avoid conflict in the test suite. (see: Naming Convention)
- Define the `ROBOT_LIBRARY_SCOPE` as `SUITE` to ensure session caching across all the test suites.
- Each method is a keyword. (e.g., `get_rhel_hostname` becomes `Get rhel hostname` keyword)
- Drivers can inherit from a base class to allow reusing common code and methods across different drivers (e.g., Rhel, CentOS, Ubuntu, etc.).

The naming convention is that the file name and the class name must be the same and start with a capital letter.

=== Keyword Naming Convention

The following naming convention ensures that Robot Framework keywords are clear, consistent, and easy to understand. Each keyword should begin with a verb, followed by the service name, and finally the task to be performed.

- *Verb*: An infinitive verb describing the action that the keyword will perform (e.g., "start", "stop", "get", "check", "set", "validate", etc.).
- *Service Name*: The name of the service or application that the action will be performed on (e.g., "yum", "apache", "docker", "mysql", etc.). Use the official or common name of the service. If the service has a prefix or suffix (e.g., "httpd" for Apache), use it consistently.
- *Task*: The specific task or state to be performed or checked, related to the action and service (e.g., "status", "state", "service", "running", "enabled", etc.).

Use underscores (_) to separate parts of the name. For example, `start_apache_service` instead of `startApacheService`.

=== Documentation

Each function or class need to be documented with reST docstring.

[source,python]
----
from robot.api.deco import library, keyword
from sysbot.connectors import ConnectorHandler
from datetime import datetime
import pytz

class Dl360(ConnectorHandler):
    """
    This class is used to interact with Ilo devices. <1>
    """

    ROBOT_LIBRARY_SCOPE = 'SUITE' <2>
    ROBOT_LIBRARY_DOC_FORMAT = 'reST' <3>

    def __init__(self) -> None:
        super().__init__()

    def get_ndcn_version(self, alias: str) -> str: <4>
        """
        Retrieves the NDCN version of the Ilo device. <5>
        """
        try:
            result = self.execute_command(alias, '/redfish/v1/Systems/1')
            return result['AssetTag']
        except Exception as e:
            raise Exception(f"Failed to get NDCN version: {str(e)}")
----
<1> Brief description of the module
<2> Set the library scope to test suite to prevent connexion loss
<3> Set the library doc format to reST. This is mandatory to generate the documentation
<4> Add prototype on the function. This is mandatory to generate the documentation
<5> Brief description of the keyword functionnalities


== Product and generate the documentation

=== Antora structure

[listing]
----
ğŸ“‚ {{modules_name}} <1>
  ğŸ“‚ docs <2>
    ğŸ“‚ modules
      ğŸ“‚ {{modules_name}} <4>
        ğŸ“‚ attachments <5>
        ğŸ“‚ images <6>
        ğŸ“‚ pages <7> 
            ğŸ“„ index.adoc
        ğŸ“„ nav.adoc <8>
    ğŸ“‚ sources
      ğŸ“‚ mermaid
    ğŸ“„ antora.yml <3>
----
<1> Name of the gitlab repository
<2> Root directory of the antora documentation 
<3> Configuration of the module
<4> Name of the module (same as the gitlab repository)
<5> Store the html documentation of the keyword generated by libdoc
<6> Image path to reference to it
<7> Each file `.adoc` in this repository are a pages in the websites
<8> Navigation configuration

[NOTE]
.External ressources
====
* https://docs.antora.org/antora/latest/[Antora documentation]
* https://docs.asciidoctor.org/asciidoc/latest/[Asciidoc documentation]
* https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/[Syntax quick reference]
====

=== Robotframework keyword documentation


== Product and generate the documentation

=== Antora structure

[listing]
----
ğŸ“‚ {{modules_name}} <1>
  ğŸ“‚ docs <2>
    ğŸ“‚ modules
      ğŸ“‚ {{modules_name}} <4>
        ğŸ“‚ attachments <5>
        ğŸ“‚ images <6>
        ğŸ“‚ pages <7> 
            ğŸ“„ index.adoc
        ğŸ“„ nav.adoc <8>
    ğŸ“‚ sources
      ğŸ“‚ mermaid
    ğŸ“„ antora.yml <3>
----
<1> Name of the gitlab repository
<2> Root directory of the antora documentation 
<3> Configuration of the module
<4> Name of the module (same as the gitlab repository)
<5> Store the html documentation of the keyword generated by libdoc
<6> Image path to reference to it
<7> Each file `.adoc` in this repository are a pages in the websites
<8> Navigation configuration

[NOTE]
.External ressources
====
* https://docs.antora.org/antora/latest/[Antora documentation]
* https://docs.asciidoctor.org/asciidoc/latest/[Asciidoc documentation]
* https://docs.asciidoctor.org/asciidoc/latest/syntax-quick-reference/[Syntax quick reference]
====

=== Robotframework keyword documentation

[source,shell]
.Generate the drivers documentation
.Generate the drivers documentation
----
pip install docutils <1>
libdoc -F REST {{module_name}}.{{drivers_name}} docs/modules/{{module_name}}/attachments/{{drivers_name}}.html <2>
libdoc -F REST sysbotWindows.Wsus docs/modules/sysbotWindows/attachments/wsus.html <3>
----
<1> Install the requirements
<2> Templated command
<3> example

[source, yaml]
.Update the nav.adoc if necessary to add the new module reference
----
* xref:index.adoc[Overview]
* Available services
** xref:sysbotWindows:attachment$Windows.html[sysbotWindows.Windows]
** xref:sysbotWindows:attachment$Adds.html[sysbotWindows.Adds]
** xref:sysbotWindows:attachment$Adcs.html[sysbotWindows.Adcs]
** xref:sysbotWindows:attachment$Veeam.html[sysbotWindows.Veeam]
** xref:sysbotWindows:attachment$Wsus.html[sysbotWindows.Wsus] <1>
----
<1> Add new reference to the attachment
pip install docutils <1>
libdoc -F REST {{module_name}}.{{drivers_name}} docs/modules/{{module_name}}/attachments/{{drivers_name}}.html <2>
libdoc -F REST sysbotWindows.Wsus docs/modules/sysbotWindows/attachments/wsus.html <3>
----
<1> Install the requirements
<2> Templated command
<3> example

[source, yaml]
.Update the nav.adoc if necessary to add the new module reference
----
* xref:index.adoc[Overview]
* Available services
** xref:sysbotWindows:attachment$Windows.html[sysbotWindows.Windows]
** xref:sysbotWindows:attachment$Adds.html[sysbotWindows.Adds]
** xref:sysbotWindows:attachment$Adcs.html[sysbotWindows.Adcs]
** xref:sysbotWindows:attachment$Veeam.html[sysbotWindows.Veeam]
** xref:sysbotWindows:attachment$Wsus.html[sysbotWindows.Wsus] <1>
----
<1> Add new reference to the attachment